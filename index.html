<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRYPTO RUNNER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        body {
            background: #000;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #header {
            width: 100%;
            max-width: 1600px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            background: #000;
        }

        #title {
            font-size: 24px;
            color: #fff;
            text-shadow: 4px 4px 0px #666;
        }

        #stats {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-end;
        }

        .stat-line {
            font-size: 12px;
            color: #fff;
            text-shadow: 2px 2px 0px #666;
        }

        .stat-value {
            color: #ffeb3b;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 1600px;
            height: 700px;
            background: #5c94fc;
            border: 8px solid #000;
            box-shadow: 0 0 0 4px #fff;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        #chartOverlay {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 320px;
            height: 180px;
            background: #000;
            border: 4px solid #fff;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #chartHeader {
            padding: 8px;
            background: #000;
            border-bottom: 2px solid #fff;
            font-size: 8px;
            color: #0f0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .live-dot {
            width: 8px;
            height: 8px;
            background: #0f0;
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        #instructions {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: #000;
            padding: 12px 16px;
            border: 4px solid #fff;
            font-size: 10px;
            color: #fff;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
        }

        .key {
            color: #ffeb3b;
        }

        #pauseOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            padding: 32px 48px;
            border: 8px solid #fff;
            font-size: 16px;
            color: #fff;
            text-align: center;
            display: none;
            box-shadow: 8px 8px 0px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="title">CRYPTO RUNNER</div>
        <div id="stats">
            <div class="stat-line">PLAYERS <span class="stat-value" id="count">1</span></div>
            <div class="stat-line">SCORE <span class="stat-value" id="score">0</span></div>
            <div class="stat-line">PRICE <span class="stat-value" id="priceChange">---</span></div>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="chartOverlay">
            <div id="chartHeader">
                <div class="live-dot"></div>
                <span>LIVE CHART</span>
            </div>
            <iframe 
                id="birdeyeChart"
                width="100%" 
                height="144px" 
                src="https://birdeye.so/tv-widget/J6pQQ3FAcJQeWPPGppWRb4nM8jU3wLyYbRrLh7feMfvd?chain=solana&viewMode=pair&chartInterval=1&chartType=Candle&chartTimezone=Europe%2FLondon&chartLeftToolbar=hide&theme=dark" 
                frameborder="0" 
                allowfullscreen>
            </iframe>
        </div>
        <div id="instructions">
            <span class="key">ARROW KEYS</span> MOVE<br>
            <span class="key">SPACE</span> JUMP
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, onValue, update, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBcVNexKQm64Uyrrk1hBVPNb3WnCt3fd9E",
            authDomain: "breloom-520aa.firebaseapp.com",
            databaseURL: "https://breloom-520aa-default-rtdb.firebaseio.com",
            projectId: "breloom-520aa",
            storageBucket: "breloom-520aa.firebasestorage.app",
            messagingSenderId: "19503362635",
            appId: "1:19503362635:web:697a5aa57ee0074f2813ce",
            measurementId: "G-4QR1YWRBSM"
        };

        let app, database;
        try {
            app = initializeApp(firebaseConfig);
            database = getDatabase(app);
        } catch (error) {
            console.error("Firebase error:", error);
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 700;

        const playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        
        const players = new Map();
        let score = 0;
        let localPlayer = {
            x: 50,
            y: 200,
            vx: 0,
            vy: 0,
            width: 16,
            height: 16,
            grounded: false,
            color: '#ff0000',
            facing: 1
        };

        // Candle data
        class Candle {
            constructor(open, high, low, close, x) {
                this.open = open;
                this.high = high;
                this.low = low;
                this.close = close;
                this.x = x;
                this.width = 24;
            }

            get color() {
                return this.close >= this.open ? '#00ff00' : '#ff0000';
            }

            get bodyTop() {
                return Math.min(this.open, this.close);
            }

            get bodyBottom() {
                return Math.max(this.open, this.close);
            }
        }

        let candles = [];
        let worldScrollX = 0;
        const CANDLE_SPACING = 12;
        const CANDLE_WIDTH = 24;
        const PRICE_SCALE = 3.5;
        const BASE_HEIGHT = 550;

        function generateCandle(prevClose, index) {
            const volatility = 18;
            const open = prevClose;
            const change = (Math.random() - 0.48) * volatility;
            const close = open + change;
            
            const high = Math.max(open, close) + Math.random() * volatility * 0.6;
            const low = Math.min(open, close) - Math.random() * volatility * 0.6;
            
            return new Candle(open, high, low, close, index * (CANDLE_WIDTH + CANDLE_SPACING));
        }

        let lastPrice = 100;
        // Generate starting platform
        for (let i = 0; i < 100; i++) {
            const candle = generateCandle(lastPrice, i);
            candles.push(candle);
            lastPrice = candle.close;
        }

        setInterval(() => {
            const candle = generateCandle(lastPrice, candles.length);
            candles.push(candle);
            lastPrice = candle.close;
            
            const priceChange = ((candle.close - candle.open) / candle.open * 100).toFixed(1);
            document.getElementById('priceChange').textContent = (priceChange >= 0 ? '+' : '') + priceChange + '%';
        }, 3000);

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const MOVE_SPEED = 3;
        const FRICTION = 0.85;

        function updatePlayer() {
            if (keys['ArrowLeft'] || keys['a']) {
                localPlayer.vx = -MOVE_SPEED;
                localPlayer.facing = -1;
            } else if (keys['ArrowRight'] || keys['d']) {
                localPlayer.vx = MOVE_SPEED;
                localPlayer.facing = 1;
            } else {
                localPlayer.vx *= FRICTION;
            }

            localPlayer.vy += GRAVITY;
            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;

            // Camera follows player (both X and Y)
            const targetScrollX = localPlayer.x - canvas.width * 0.3;
            worldScrollX += (targetScrollX - worldScrollX) * 0.1;
            worldScrollX = Math.max(0, worldScrollX);
            
            // Calculate camera Y offset to keep player in view
            const cameraTargetY = localPlayer.y - canvas.height * 0.5;
            if (!window.cameraY) window.cameraY = 0;
            window.cameraY += (cameraTargetY - window.cameraY) * 0.1;

            localPlayer.grounded = false;
            
            // Check collision with candles
            candles.forEach(candle => {
                const candleScreenX = candle.x - worldScrollX;
                const playerScreenX = localPlayer.x - worldScrollX;
                
                // Player must be within candle's horizontal bounds
                if (playerScreenX + localPlayer.width > candleScreenX && 
                    playerScreenX < candleScreenX + CANDLE_WIDTH) {
                    
                    const bodyTopY = BASE_HEIGHT - candle.bodyTop * PRICE_SCALE;
                    
                    // Landing on top of candle
                    if (localPlayer.y + localPlayer.height >= bodyTopY - 5 && 
                        localPlayer.y + localPlayer.height <= bodyTopY + 10 &&
                        localPlayer.vy >= 0) {
                        localPlayer.y = bodyTopY - localPlayer.height;
                        localPlayer.vy = 0;
                        localPlayer.grounded = true;
                    }
                }
            });

            // Jump
            if ((keys[' '] || keys['ArrowUp']) && localPlayer.grounded) {
                localPlayer.vy = JUMP_FORCE;
                localPlayer.grounded = false;
            }

            // Update score based on distance
            score = Math.floor(localPlayer.x / 10);
            document.getElementById('score').textContent = score;

            // Game over if player falls off screen
            if (localPlayer.y > canvas.height) {
                localPlayer.x = 50;
                localPlayer.y = 200;
                localPlayer.vy = 0;
                worldScrollX = 0;
                score = 0;
                document.getElementById('score').textContent = score;
            }

            if (database && Math.random() < 0.25) {
                update(ref(database, 'players/' + playerId), {
                    x: Math.round(localPlayer.x),
                    y: Math.round(localPlayer.y),
                    color: localPlayer.color,
                    facing: localPlayer.facing,
                    timestamp: Date.now()
                });
            }
        }

        function drawPixelBlock(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x, y, w, 2);
            ctx.fillRect(x, y, 2, h);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(x, y + h - 2, w, 2);
            ctx.fillRect(x + w - 2, y, 2, h);
        }

        function drawCandles() {
            ctx.save();
            ctx.translate(0, -window.cameraY || 0);
            
            candles.forEach(candle => {
                const screenX = candle.x - worldScrollX;
                
                if (screenX > -50 && screenX < canvas.width + 50) {
                    const highY = BASE_HEIGHT - candle.high * PRICE_SCALE;
                    const lowY = BASE_HEIGHT - candle.low * PRICE_SCALE;
                    const bodyTopY = BASE_HEIGHT - candle.bodyTop * PRICE_SCALE;
                    const bodyBottomY = BASE_HEIGHT - candle.bodyBottom * PRICE_SCALE;
                    
                    // Wick
                    ctx.fillStyle = candle.color;
                    ctx.fillRect(screenX + CANDLE_WIDTH / 2 - 2, highY, 4, lowY - highY);
                    
                    // Body
                    const bodyHeight = Math.max(bodyBottomY - bodyTopY, 4);
                    drawPixelBlock(screenX, bodyTopY, CANDLE_WIDTH, bodyHeight, candle.color);
                }
            });
            
            ctx.restore();
        }

        function drawPlayer(player, isLocal = false) {
            ctx.save();
            ctx.translate(0, -window.cameraY || 0);
            
            const screenX = player.x - worldScrollX;
            const x = screenX;
            const y = player.y;
            const w = player.width;
            const h = player.height;
            
            // Body
            drawPixelBlock(x, y, w, h, player.color);
            
            // Eyes
            ctx.fillStyle = '#fff';
            if (player.facing === 1) {
                ctx.fillRect(x + 8, y + 4, 4, 4);
            } else {
                ctx.fillRect(x + 4, y + 4, 4, 4);
            }
            
            ctx.fillStyle = '#000';
            if (player.facing === 1) {
                ctx.fillRect(x + 10, y + 5, 2, 2);
            } else {
                ctx.fillRect(x + 4, y + 5, 2, 2);
            }

            // Hat
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 2, y - 4, w - 4, 4);
            ctx.fillRect(x + 4, y - 6, w - 8, 2);

            if (isLocal) {
                ctx.fillStyle = '#ffeb3b';
                ctx.font = '8px "Press Start 2P"';
                ctx.fillText('P1', x - 2, y - 8);
            }
            
            ctx.restore();
        }

        function drawClouds() {
            for (let i = 0; i < 8; i++) {
                const x = (i * 250 + worldScrollX * 0.3) % (canvas.width + 200) - 100;
                const y = 50 + (i * 37) % 150;
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(x, y, 48, 16);
                ctx.fillRect(x + 8, y - 8, 32, 8);
                ctx.fillRect(x + 16, y - 16, 16, 8);
            }
        }

        function drawFloor() {
            // No floor - players can fall off!
        }

        function gameLoop() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#5c94fc');
            gradient.addColorStop(1, '#4080e8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawClouds();
            drawCandles();
            drawFloor();
            updatePlayer();
            drawPlayer(localPlayer, true);

            players.forEach((player, id) => {
                if (id !== playerId) {
                    drawPlayer(player);
                }
            });

            requestAnimationFrame(gameLoop);
        }

        if (database) {
            const playersRef = ref(database, 'players');
            const playerRef = ref(database, 'players/' + playerId);
            
            onDisconnect(playerRef).remove();
            
            onValue(playersRef, (snapshot) => {
                const data = snapshot.val();
                players.clear();
                let count = 0;
                
                if (data) {
                    Object.keys(data).forEach(id => {
                        const player = data[id];
                        if (Date.now() - player.timestamp < 10000) {
                            players.set(id, player);
                            count++;
                        }
                    });
                }
                
                document.getElementById('count').textContent = count;
            });

            window.addEventListener('beforeunload', () => {
                remove(playerRef);
            });
        }

        gameLoop();
    </script>
</body>
</html>
