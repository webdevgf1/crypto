<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRYPTO RUNNER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0e1117;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #header {
            width: 100%;
            max-width: 1920px;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #131722;
            border-bottom: 1px solid #2a2e39;
        }

        #tokenInfo {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #title {
            font-size: 16px;
            color: #fff;
        }

        #priceInfo {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #price {
            font-size: 18px;
            color: #089981;
            font-weight: bold;
        }

        #priceChange {
            font-size: 10px;
            color: #089981;
        }

        #priceChange.negative {
            color: #f23645;
        }

        #stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat-box {
            background: #1e222d;
            padding: 8px 16px;
            border-radius: 4px;
            border: 1px solid #2a2e39;
        }

        .stat-label {
            font-size: 8px;
            color: #787b86;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 12px;
            color: #fff;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 1920px;
            height: 850px;
            background: #131722;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            height: 160px;
            background: rgba(30, 34, 45, 0.95);
            border: 2px solid #2a2e39;
            border-radius: 6px;
            overflow: hidden;
            z-index: 10;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        #minimap.expanded {
            width: 560px;
            height: 320px;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        #minimapHeader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 12px;
            background: rgba(19, 23, 34, 0.9);
            border-bottom: 1px solid #2a2e39;
            font-size: 8px;
            color: #787b86;
            pointer-events: none;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 34, 45, 0.95);
            padding: 12px 16px;
            border: 2px solid #2a2e39;
            font-size: 10px;
            color: #fff;
            border-radius: 6px;
            z-index: 3;
        }

        .key {
            color: #089981;
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="tokenInfo">
            <div id="title">2Z/USD</div>
            <div id="priceInfo">
                <div id="price">$0.7084</div>
                <div id="priceChange">+2.45%</div>
            </div>
        </div>
        <div id="stats">
            <div class="stat-box">
                <div class="stat-label">PLAYERS</div>
                <div class="stat-value" id="count">1</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">DISTANCE</div>
                <div class="stat-value"><span id="score">0</span>m</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">HIGH SCORE</div>
                <div class="stat-value"><span id="highscore">0</span>m</div>
            </div>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="minimap">
            <div id="minimapHeader">MAP - CLICK TO EXPAND</div>
            <canvas id="minimapCanvas"></canvas>
        </div>
        <div id="instructions">
            <span class="key">← →</span> MOVE | <span class="key">SPACE</span> JUMP
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, onValue, update, remove, onDisconnect } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBcVNexKQm64Uyrrk1hBVPNb3WnCt3fd9E",
            authDomain: "breloom-520aa.firebaseapp.com",
            databaseURL: "https://breloom-520aa-default-rtdb.firebaseio.com",
            projectId: "breloom-520aa",
            storageBucket: "breloom-520aa.firebasestorage.app",
            messagingSenderId: "19503362635",
            appId: "1:19503362635:web:697a5aa57ee0074f2813ce",
            measurementId: "G-4QR1YWRBSM"
        };

        let app, database;
        try {
            app = initializeApp(firebaseConfig);
            database = getDatabase(app);
        } catch (error) {
            console.error("Firebase error:", error);
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1920;
        canvas.height = 850;

        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 280;
        minimapCanvas.height = 160;

        const minimapEl = document.getElementById('minimap');
        let minimapExpanded = false;
        
        minimapEl.addEventListener('click', () => {
            minimapExpanded = !minimapExpanded;
            minimapEl.classList.toggle('expanded');
            if (minimapExpanded) {
                minimapCanvas.width = 560;
                minimapCanvas.height = 320;
            } else {
                minimapCanvas.width = 280;
                minimapCanvas.height = 160;
            }
        });

        const playerId = 'player_' + Math.random().toString(36).substr(2, 9);
        const players = new Map();
        let score = 0;
        let highscore = localStorage.getItem('highscore') || 0;
        document.getElementById('highscore').textContent = highscore;

        let platforms = [];
        let cameraX = 0;

        // Extract token info from BirdEye URL
        const BIRDEYE_TOKEN = 'J6pQQ3FAcJQeWPPGppWRb4nM8jU3wLyYbRrLh7feMfvd';
        let tokenData = {
            symbol: '2Z',
            name: '2Z/USD',
            price: 0.7084,
            change: 2.45
        };

        // Fetch real token data from BirdEye API
        async function fetchTokenData() {
            try {
                const response = await fetch(`https://public-api.birdeye.so/public/token_overview?address=${BIRDEYE_TOKEN}`, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.data) {
                        tokenData.symbol = data.data.symbol || '2Z';
                        tokenData.name = `${data.data.symbol}/USD` || '2Z/USD';
                        tokenData.price = data.data.price || 0.7084;
                        tokenData.change = data.data.priceChange24h || 2.45;
                        
                        updateHeaderDisplay();
                    }
                }
            } catch (e) {
                console.log('Using default token data');
            }
        }

        function updateHeaderDisplay() {
            document.getElementById('title').textContent = tokenData.name;
            document.getElementById('price').textContent = '$' + tokenData.price.toFixed(4);
            const changeEl = document.getElementById('priceChange');
            changeEl.textContent = (tokenData.change >= 0 ? '+' : '') + tokenData.change.toFixed(2) + '%';
            changeEl.className = tokenData.change >= 0 ? '' : 'negative';
            if (tokenData.change >= 0) {
                document.getElementById('price').style.color = '#089981';
            } else {
                document.getElementById('price').style.color = '#f23645';
            }
        }

        // Fetch token data on load
        fetchTokenData();
        // Update every 30 seconds
        setInterval(fetchTokenData, 30000);

        const CANDLE_WIDTH = 16;
        const CANDLE_GAP = 4;
        const CANDLE_SPACING = CANDLE_WIDTH + CANDLE_GAP;

        let localPlayer = {
            x: 100,
            y: 400,
            vx: 0,
            vy: 0,
            width: 16,
            height: 16,
            grounded: false,
            color: '#ff0000',
            facing: 1
        };

        // Generate realistic chart candles
        function generateInitialPlatforms() {
            platforms = [];
            let price = 400;
            let trend = 0;
            let momentum = 0;
            
            for (let i = 0; i < 400; i++) {
                const x = i * CANDLE_SPACING;
                
                // Realistic price movement with momentum
                momentum += (Math.random() - 0.5) * 0.3;
                momentum *= 0.92;
                trend += momentum;
                trend *= 0.98;
                
                const volatility = 15 + Math.random() * 25;
                price += trend * 5 + (Math.random() - 0.5) * volatility;
                price = Math.max(200, Math.min(650, price));
                
                const open = price;
                const change = (Math.random() - 0.5) * 30;
                const close = open + change;
                
                const high = Math.max(open, close) + Math.random() * 15;
                const low = Math.min(open, close) - Math.random() * 15;
                
                const bodyTop = Math.min(open, close);
                const bodyBottom = Math.max(open, close);
                const bodyHeight = Math.max(bodyBottom - bodyTop, 3);
                
                const isGreen = close >= open;
                
                platforms.push({
                    x: x,
                    y: canvas.height - bodyBottom - 100,
                    width: CANDLE_WIDTH,
                    height: bodyHeight,
                    wickTop: canvas.height - high - 100,
                    wickBottom: canvas.height - low - 100,
                    color: isGreen ? '#089981' : '#f23645',
                    isGreen: isGreen,
                    open: open,
                    close: close,
                    high: high,
                    low: low
                });
                
                price = close;
            }
        }

        generateInitialPlatforms();

        // Add new candles that follow market trend
        setInterval(() => {
            const lastPlatform = platforms[platforms.length - 1];
            const lastPrice = lastPlatform.close;
            
            // Calculate trend from last 5 candles
            let trendSum = 0;
            for (let i = Math.max(0, platforms.length - 5); i < platforms.length - 1; i++) {
                trendSum += platforms[i + 1].close - platforms[i].close;
            }
            const trend = trendSum / 5;
            
            const open = lastPrice;
            const change = trend * 0.6 + (Math.random() - 0.5) * 25;
            const close = open + change;
            
            const high = Math.max(open, close) + Math.random() * 15;
            const low = Math.min(open, close) - Math.random() * 15;
            
            const bodyTop = Math.min(open, close);
            const bodyBottom = Math.max(open, close);
            const bodyHeight = Math.max(bodyBottom - bodyTop, 3);
            
            const isGreen = close >= open;
            const newX = lastPlatform.x + CANDLE_SPACING;
            
            platforms.push({
                x: newX,
                y: canvas.height - bodyBottom - 100,
                width: CANDLE_WIDTH,
                height: bodyHeight,
                wickTop: canvas.height - high - 100,
                wickBottom: canvas.height - low - 100,
                color: isGreen ? '#089981' : '#f23645',
                isGreen: isGreen,
                open: open,
                close: close,
                high: high,
                low: low
            });
            
            // Update price display dynamically
            const priceChange = ((close - open) / open * 100).toFixed(2);
            const newPrice = (tokenData.price * (1 + (close - 400) * 0.0001)).toFixed(4);
            tokenData.price = parseFloat(newPrice);
            tokenData.change = parseFloat(priceChange);
            updateHeaderDisplay();
        }, 2000);

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        const GRAVITY = 0.6;
        const JUMP_FORCE = -13;
        const MOVE_SPEED = 5;
        const FRICTION = 0.85;

        function updatePlayer() {
            if (keys['ArrowLeft'] || keys['a']) {
                localPlayer.vx = -MOVE_SPEED;
                localPlayer.facing = -1;
            } else if (keys['ArrowRight'] || keys['d']) {
                localPlayer.vx = MOVE_SPEED;
                localPlayer.facing = 1;
            } else {
                localPlayer.vx *= FRICTION;
            }

            localPlayer.vy += GRAVITY;
            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;

            cameraX = localPlayer.x - canvas.width * 0.3;
            cameraX = Math.max(0, cameraX);

            localPlayer.grounded = false;
            
            // Collision with candle bodies only (not gaps)
            platforms.forEach(platform => {
                if (localPlayer.x + localPlayer.width > platform.x + 2 && 
                    localPlayer.x < platform.x + platform.width - 2 &&
                    localPlayer.y + localPlayer.height >= platform.y &&
                    localPlayer.y + localPlayer.height <= platform.y + 15 &&
                    localPlayer.vy >= 0) {
                    
                    localPlayer.y = platform.y - localPlayer.height;
                    localPlayer.vy = 0;
                    localPlayer.grounded = true;
                }
            });

            if ((keys[' '] || keys['ArrowUp']) && localPlayer.grounded) {
                localPlayer.vy = JUMP_FORCE;
                localPlayer.grounded = false;
            }

            score = Math.floor(localPlayer.x / 10);
            document.getElementById('score').textContent = score;
            
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('highscore', highscore);
                document.getElementById('highscore').textContent = highscore;
            }

            if (localPlayer.y > canvas.height + 100) {
                localPlayer.x = 100;
                localPlayer.y = 400;
                localPlayer.vy = 0;
                cameraX = 0;
            }

            if (database && Math.random() < 0.2) {
                update(ref(database, 'players/' + playerId), {
                    x: Math.round(localPlayer.x),
                    y: Math.round(localPlayer.y),
                    color: localPlayer.color,
                    facing: localPlayer.facing,
                    timestamp: Date.now()
                });
            }
        }

        function drawChart() {
            // Grid
            ctx.strokeStyle = '#1e222d';
            ctx.lineWidth = 1;
            
            const startX = Math.floor(cameraX / 50) * 50;
            for (let x = startX; x < cameraX + canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x - cameraX, 0);
                ctx.lineTo(x - cameraX, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawCandles() {
            platforms.forEach(platform => {
                const screenX = platform.x - cameraX;
                
                if (screenX > -50 && screenX < canvas.width + 50) {
                    // Wick
                    ctx.strokeStyle = platform.color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX + platform.width / 2, platform.wickTop);
                    ctx.lineTo(screenX + platform.width / 2, platform.wickBottom);
                    ctx.stroke();
                    
                    // Body
                    ctx.fillStyle = platform.color;
                    ctx.fillRect(screenX, platform.y, platform.width, platform.height);
                }
            });
        }

        function drawPlayer(player, isLocal = false) {
            const screenX = player.x - cameraX;
            
            ctx.fillStyle = player.color;
            ctx.fillRect(screenX, player.y, player.width, player.height);
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX, player.y, player.width, player.height);
            
            ctx.fillStyle = '#fff';
            if (player.facing === 1) {
                ctx.fillRect(screenX + 8, player.y + 4, 4, 4);
            } else {
                ctx.fillRect(screenX + 4, player.y + 4, 4, 4);
            }
            
            ctx.fillStyle = '#000';
            if (player.facing === 1) {
                ctx.fillRect(screenX + 10, player.y + 5, 2, 2);
            } else {
                ctx.fillRect(screenX + 4, player.y + 5, 2, 2);
            }

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(screenX + 2, player.y - 4, player.width - 4, 4);

            if (isLocal) {
                ctx.fillStyle = '#ffeb3b';
                ctx.font = '8px "Press Start 2P"';
                ctx.fillText('P1', screenX - 2, player.y - 8);
            }
        }

        function drawMinimap() {
            minimapCtx.fillStyle = '#131722';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            const scale = minimapExpanded ? 0.15 : 0.075;
            const centerOffset = minimapExpanded ? 280 : 140;
            
            platforms.forEach(platform => {
                const mx = (platform.x - cameraX + centerOffset) * scale;
                const my = platform.y * scale * 0.5;
                
                if (mx > 0 && mx < minimapCanvas.width) {
                    minimapCtx.fillStyle = platform.color;
                    minimapCtx.fillRect(mx, my, 1, 2);
                }
            });
            
            const playerMapX = (localPlayer.x - cameraX + centerOffset) * scale;
            const playerMapY = localPlayer.y * scale * 0.5;
            
            minimapCtx.fillStyle = '#ffeb3b';
            minimapCtx.beginPath();
            minimapCtx.arc(playerMapX, playerMapY, 5, 0, Math.PI * 2);
            minimapCtx.fill();
            
            minimapCtx.strokeStyle = '#ff0000';
            minimapCtx.lineWidth = 2;
            minimapCtx.stroke();
        }

        function gameLoop() {
            ctx.fillStyle = '#131722';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawChart();
            drawCandles();
            updatePlayer();
            drawPlayer(localPlayer, true);

            players.forEach((player, id) => {
                if (id !== playerId) {
                    drawPlayer(player);
                }
            });

            drawMinimap();
            requestAnimationFrame(gameLoop);
        }

        if (database) {
            const playersRef = ref(database, 'players');
            const playerRef = ref(database, 'players/' + playerId);
            
            onDisconnect(playerRef).remove();
            
            onValue(playersRef, (snapshot) => {
                const data = snapshot.val();
                players.clear();
                let count = 0;
                
                if (data) {
                    Object.keys(data).forEach(id => {
                        const player = data[id];
                        if (Date.now() - player.timestamp < 10000) {
                            players.set(id, player);
                            count++;
                        }
                    });
                }
                
                document.getElementById('count').textContent = count;
            });

            window.addEventListener('beforeunload', () => {
                remove(playerRef);
            });
        }

        gameLoop();
    </script>
</body>
</html>
